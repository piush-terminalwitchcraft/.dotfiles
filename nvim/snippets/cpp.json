
"Minimal C++ code ": {
  "prefix": "minimal",
  "body": [
    "#include <bits/stdc++.h>",
    "typedef long long ll;",
    "",
    "int32_t main(){",
    "\t$1",
    "\treturn 0;",
    "}"
  ],
  "description": "Minimal C++ code "
  },
     "Begineer's c++ code for competitive programming": {
  "prefix": "beg",
  "body": [
    "#ifdef ONPC",
    "    #define _GLIBCXX_DEBUG",
    "#endif",
    "#include <bits/stdc++.h>",
    "#define sz(a) ((int)((a).size()))",
    "#define ps(x, y) std::fixed << std::setprecision(y) << x",
    "#define setbit(x) __builtin_popcountll(x)",
    "#define PI 3.141592653589793",
    "#define Yes cout<<\"Yes\\n\" ",
    "#define No cout << \"No\\n\"",
    "#define YES cout<<\"Yes\\n\" ",
    "#define NO cout << \"No\\n\"",
    "#define rep(i, a, b) for (int i = a; i < b; ++i)",
    "#define ff first",
    "#define ss second",
    "#define pb push_back",
    "#define repr(i, a, b) for (int i = a; i >= b; --i)",
    "",
    " ",
    "// mt19937 rnd(239);",
    "std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());",
    " ",
    "typedef long long int ll;",
    "typedef long double ld;",
    "typedef std::pair<int, int> pii;",
    "typedef std::pair<ll, ll> pll;",
    "typedef std::vector<int> vi;",
    "typedef std::vector<ll> vll;",
    "typedef std::vector<pii> vpii;",
    "typedef std::vector<pll> vpll;",
    "typedef std::map<int, int> mii;",
    "",
    "const ll MOD = 1e9 + 7;",
    "const ll INF = 1000000000;",
    "const ll MAX_N = 2e5 + 2;",
    "ll add(ll x, ll y) {ll res=x+y; return(res>=MOD?res-MOD:res);}",
    "ll mul(ll x, ll y) {ll res=x*y; return(res>=MOD?res%MOD:res);}",
    "ll sub(ll x, ll y) {ll res=x-y; return(res<0?res+MOD:res);}",
    "ll power(ll a,ll b,ll m=MOD){ ll ans=1; a=a%m;  while(b>0) {  if(b&1)  ans=(1ll*a*ans)%m; b>>=1;a=(1ll*a*a)%m;}return ans;}",
    "",
    "",
    "int solve() {",
    "    $1",
    "    return 0;",
    "}",
    " ",
    "int32_t main() {",
    "    std::ios::sync_with_stdio(0);",
    "    std::cin.tie(0);",
    "    int TET = 1e9;",
    "    //std::cin >> TET;",
    "    for (int i = 1; i <= TET; i++) {",
    "        if (solve()) {",
    "            break;",
    "        }",
    "        #ifdef ONPC",
    "            std::cout << \"__________________________\" << std::endl;",
    "        #endif",
    "    }",
    "    #ifdef ONPC",
    "        std::cerr << std::endl << \"finished in \" << clock() * 1.0 / CLOCKS_PER_SEC << \" sec\" << std::endl;",
    "    #endif",
    "}"
  ],
  "description": "Begineer's c++ code for competitive programming"
},

"Segment tree": {
  "prefix": "segtree",
  "body": [
    "struct segmenttree",
    "{",
    "    int n;",
    "    std::vector<int> st;",
    "    std::vector<std::pair<int,int>>lazy;",
    "",
    "    void init(int _n)",
    "    {",
    "        this->n = _n;",
    "        st.resize(4 * n, 0);",
    "        lazy.resize(4 * n, {0, 0});",
    "    }",
    "",
    "    void push(int start, int ending, int node)",
    "    {",
    "        if (lazy[node].first)",
    "        {",
    "            st[node] = (ending - start + 1) * lazy[node].second;",
    "",
    "            if (start != ending)",
    "            {",
    "                lazy[2 * node + 1] = lazy[node];",
    "                lazy[2 * node + 2] = lazy[node];",
    "            }",
    "",
    "            lazy[node].first = 0;",
    "        }",
    "    }",
    "",
    "    void build(int start, int ending, int node, std::vector<int> &v)",
    "    {",
    "        if (start == ending)",
    "        {",
    "            st[node] = v[start];",
    "            return;",
    "        }",
    "",
    "        int mid = (start + ending) / 2;",
    "",
    "        build(start, mid, 2 * node + 1, v);",
    "",
    "        build(mid + 1, ending, 2 * node + 2, v);",
    "",
    "        st[node] = st[node * 2 + 1] + st[node * 2 + 2];",
    "    }",
    "",
    "    int query(int start, int ending, int l, int r, int node)",
    "    {",
    "        push(start, ending, node);",
    "",
    "        if (start > r || ending < l)",
    "        {",
    "            return 0;",
    "        }",
    "",
    "        if (start >= l && ending <= r)",
    "        {",
    "            return st[node];",
    "        }",
    "",
    "        int mid = (start + ending) / 2;",
    "",
    "        int q1 = query(start, mid, l, r, 2 * node + 1);",
    "        int q2 = query(mid + 1, ending, l, r, 2 * node + 2);",
    "",
    "        return q1 + q2;",
    "    }",
    "",
    "    void update(int start, int ending, int node, int l, int r, int value)",
    "    {",
    "        push(start, ending, node);",
    "",
    "        if (start > r || ending < l)",
    "        {",
    "            return;",
    "        }",
    "",
    "        if (start >= l && ending <= r)",
    "        {",
    "            st[node] = (ending - start + 1) * value;",
    "",
    "            if (start != ending)",
    "            {",
    "                lazy[2 * node + 1] = {1, value};",
    "                lazy[2 * node + 2] = {1, value};",
    "            }",
    "            ",
    "            return;",
    "        }",
    "",
    "        int mid = (start + ending) / 2;",
    "",
    "        update(start, mid, 2 * node + 1, l, r, value);",
    "",
    "        update(mid + 1, ending, 2 * node + 2, l, r, value);",
    "",
    "        st[node] = st[node * 2 + 1] + st[node * 2 + 2];",
    "",
    "        return;",
    "    }",
    "",
    "    void build(std::vector<int> &v)",
    "    {",
    "        build(0, n - 1, 0, v);",
    "    }",
    "",
    "    int query(int l, int r)",
    "    {",
    "        return query(0, n - 1, l, r, 0);",
    "    }",
    "",
    "    void update(int l, int r, int x)",
    "    {",
    "        update(0, n - 1, 0, l, r, x);",
    "    }",
    "};"
  ],
  "description": "Segment tree"
},
"fenwick tree": {
  "prefix": "fenwick",
  "body": [
    "struct Fenwick {",
    "    std::vector<ll> tree;",
    "    int n;",
    " ",
    "    Fenwick(int n) : n(n) {",
    "        tree.assign(n, 0);",
    "    }",
    " ",
    "    void point_add(int pos, ll val) {",
    "        for (; pos < n; pos |= (pos + 1)) {",
    "            tree[pos] += val;",
    "        }",
    "    }",
    " ",
    "    ll find_sum(int r) { // [0, r]",
    "        ll ans = 0;",
    "        for (; r >= 0; r = (r & (r + 1)) - 1) {",
    "            ans += tree[r];",
    "        }",
    "        return ans;",
    "    }",
    " ",
    "    ll find_sum(int l, int r) { // [l, r)",
    "        return find_sum(r - 1) - find_sum(l - 1);",
    "    }",
    "};",
    " "
  ],
  "description": "fenwick tree"
}, 
"DSU snippet": {
  "prefix": "DSU",
  "body": [
    "struct DSU {",
    "    std::vector<int> pr;",
    "    int n;",
    " ",
    "    DSU(int n) : n(n) {",
    "        pr.resize(n);",
    "         std::iota(pr.begin(), pr.end(), 0);",
    "    }",
    " ",
    "    inline int findpr(int v) {",
    "        return (v == pr[v] ? v : (pr[v] = findpr(pr[v])));",
    "    }",
    " ",
    "    inline bool unite(int v, int u) {",
    "        v = findpr(v);",
    "        u = findpr(u);",
    "        if (u == v) {",
    "            return false;",
    "        } else {",
    "            pr[v] = u;",
    "            return true;",
    "        }",
    "    }",
    "};"
  ],
  "description": "DSU snippet"
},
"debugging for c++": {
  "prefix": "debug",
  "body": [
    "#ifdef ONPC",
    "    void debug_print(string s) {",
    "        cerr << \"\\\"\" << s << \"\\\"\";",
    "    }",
    "    void debug_print(bool val) {",
    "        cerr << (val ? \"true\" : \"false\");",
    "    }",
    " ",
    "    void debug_print(int val) {",
    "        cerr << val;",
    "    }",
    " ",
    "    void debug_print(ll val) {",
    "        cerr << val;",
    "    }",
    " ",
    "    template<typename F, typename S>",
    "    void debug_print(pair<F, S> val) {",
    "        cerr << \"(\";",
    "        debug_print(val.first);",
    "        cerr << \", \";",
    "        debug_print(val.second);",
    "        cerr << \")\";",
    "    }",
    " ",
    "    void debug_print(vector<bool> val) {",
    "        cerr << \"{\";",
    "        bool first = true;",
    "        for (bool x : val) {",
    "            if (!first) {",
    "                cerr << \", \";",
    "            } else {",
    "                first = false;",
    "            }",
    "            debug_print(x);",
    "        }",
    "        cerr << \"}\";",
    "    }",
    " ",
    "    template<typename T>",
    "    void debug_print(T val) {",
    "        cerr << \"{\";",
    "        bool first = true;",
    "        for (const auto &x : val) {",
    "            if (!first) {",
    "                cerr << \", \";",
    "            } else {",
    "                first = false;",
    "            }",
    "            debug_print(x);",
    "        }",
    "        cerr << \"}\";",
    "    }",
    " ",
    "    void debug_print_collection() {",
    "        cerr << endl;",
    "    }",
    " ",
    "    template<typename First, typename... Args>",
    "    void debug_print_collection(First val, Args... args) {",
    "        cerr << \" \";",
    "        debug_print(val);",
    "        debug_print_collection(args...);",
    "    }",
    " ",
    "#define debug(...) cerr << \"@@@ \" << #__VA_ARGS__ << \" =\"; debug_print_collection(__VA_ARGS__);",
    " ",
    "#else",
    "    #define debug(...) ",
    "#endif"
  ],
  "description": "debugging for c++"
}
